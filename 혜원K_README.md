# 혜원K PJT6_README

- 맡은 역할 : User 관련 기능
    - User RestController 구현
    - User Service 구현
    - User Dao, Dto 구현
    - mapper 구현
    - Login Interceptor 구현

- 트러블 슈팅
    - **세션에 대한 이해**
        
        지금까지 ‘세션’에 대해 비연결성의 특징을 갖는 http 연결 속에서 사용자의 특정 상태나 정보를 유지하기 위한 기술이라고만 알아왔다. 그러나 이번 pjt를 수행하며 세션의 의미를 확장하여 알게 되었다. 
        
        세션은 어떤 특정 기간을 의미한다. 그리고 CS에서는 일반적으로 **사용자와 시스템 간의 상호작용 기간**을 의미한다. 또한 CS에서 세션은 하나의 역할만 의미하는 것이 아니라 다양한 역할을 나타낸다.
        
        1. 웹 세션 : 
            1. 웹 어플리케이션에서 사용자의 상태를 유지하기 위해 사용하는 세션으로, 사용자가 로그인하거나 특정 작업을 수행할 때 해당 상태를 유지하여 동일한 사용자로 인식하도록 하는 것이 주요한 목적이다.
            2. 동작 원리 : 웹 서버는 사용자가 처음 접속할 때 세션 ID를 부여한다. 세션 ID는 쿠키에 저장되어 서버와 클라이언트 간의 요청이 오갈 때마다 전달되어 사용자의 상태를 확인할 수 있다.
            3. 유지시간 : 브라우저가 열려 있는 동안 또는 서버에 설정된 유효 시간 동안 유지된다. 사용자가 로그아웃하거나 세션 만료 시간이 지나면 종료된다.
            4. 용도 : 로그인 상태 유지, 장바구니 기능 등
            5. 기술 : HTTP는 기본적으로 상태가 없는 프로토콜이기 때문에, 서버는 HttpSession 객체를 사용해 세션 정보를 관리하거나, JWT와 같은 토큰을 이용하여 세션 관리를 대신할 수 있다.
        2. 데이터베이스 세션
            1. 데이터베이스와 애플리케이션 간의 연결 상태를 유지하기 위한 세션. 애플리케이션이 데이터베이스에 접근하여 데이터를 읽고 쓰는 동안 연결을 유지하는데 사용된다.
            2. 동작 원리 : 애플리케이션이 데이터베이스에 연결을 요청하면 데이터베이스가 세션을 생성한다. 이 세션은 해당 작업이 완료될 때까지 유지된다. 세션을 유지하는 동안 트랜잭션 관리, 세션 롤백, 커밋 작업 등을 수행할 수 있다.
            3. 유지 시간 : 요청 처리 중이나 일정 시간 동안 유지된다. 사용 후 바로 닫히거나, 커넥션풀(Connection Pool)을 이용해 재사용된다.  
            4. 용도 : 데이터 조회, 추가, 삭제 등의 데이터 조작을 위한 작업
            5. 기술 : JDBC, JPA와 같은 라이브러리가 데이터베이스 세션관리를 제공한다. 
        3. 네트워크 세션 : 
            1. 네트워크 통신에서 두 시스템 간에 연결을 유지하는 세션이다. 클라이언트와 서버 간, 혹은 시스템 간의 연결을 관리하고 세션을 통해 서로의 상태를 유지하게 한다.
            2. 동작 원리 : 두 시스템이 특정 프로토콜(ex. TCP/IP)로 연결되면 세션 레이어가 세션을 관리한다. 연결이 성립되면 송수신이 가능해지며, 연결이 끊어질 때까지 세션이 유지된다.
            3. 유지 시간 : 네트워크 연결이 유지되는 동안 또는 특정 타임아웃 시간 동안 유지된다. 연결이 끊기면 세션이 종료된다.
            4. 용도 : 파일 전송, 원격 명령어 실행, 스트리밍 등 실시간 데이터 교환
            5. 기술 : 소켓 프로그래밍, TCP/IP 세션 관리
        4. 응용 프로그램 세션
            1. 응용 프로그램의 상태를 유지하는 세션이다. 사용자가 응용 프로그램을 실행하고 있는 동안 필요한 데이터와 상태를 유지하기 위한 것이다.
            2. 동작 원리 : 응용 프로그램은 사용자가 접속할 때 특정 상태나 설정 값을 저장하고, 이 정보는 사용자가 프로그램을 종료할 때까지 유지된다.
            3. 유지 시간 : 애플리케이션이 실행되고 있는 동안, 또는 사용자가 명시적으로 종료할 때까지 유지된다.
            4. 용도 : 설정 상태 유지, 현재 작업 상태 관리 등
            5. 기술 : 애플리케이션 내의 특정 객체나 상태 관리 라이브러리를 통해 세션을 유지한다. 
        
        이전에는 세션의 의미를 웹 세션의 측면, 특히 HttpSession 방식으로 생각했다. 그러나 세션을 ‘상태 정보와 일관성 유지’를 위한 다양한 분야에서 다양한 기술로 구현할 수 있다는 것을 알게 되었다. 
        
    - jwt 없이 어떻게 로그인 기능을 구현할까?
        
        웹 세션과 이어지는 내용으로 jwt 없이 로그인을 어떻게 구현할지 고민해보았다. 사용자의 로그인 세션이 웹 창을 닫아도 유지되도록 하고 싶다는 목표로 고민했다. 웹 세션을 위한 기술 중 하나인 HttpSession은 서버에 생성되는 세션으로, 세션 ID가 브라우저 쿠키에 저장되기 때문에 브라우저가 닫히거나 쿠키가 삭제되면 기본적으로 세션 ID가 사라지는 특징이 있다. 따라서 창을 닫으면 새로운 세션이 생성되고, 로그인 상태는 유지되지 않는다. 따라서 이번 PJT에선 **쿠키를 사용**하여 사용자의 상태를 저장하고자 했다. 
        
        ```java
        //사용자 로그인 처리가 확인 되면 쿠키를 생성하여 고유한 유저의 아이디를 저장했다
        //실제론 보안상 문제가 크기 때문에 이후엔 jwt로 적용하고자 한다.
        Cookie cookie = new Cookie ("LogIn", user.getId());
        //HTTP 전송만 허용하여 JavaScirpt와 같은 클라이언트 스크립트에서 쿠키에 접근하지 못하게 설정한다.(보안 강화 측면)
        cookie.setHttpOnly(true);
        
        //쿠키의 유효 경로를 웹 애플리케이션 전체("/")로 설정하여 모든 요청 경로에서 사용 가능하도록 한다.
        cookie.setPath("/");
        
        //쿠키 만료 시간을 정한다.
        cookie.setMaxAge(24*60*60);
        
        //설정한 쿠키를 Http 응답에 추가하여 클라이언트에게 전송
        response.addCookie(cookie);
        ```
        
        이 쿠키를 기반으로 Interceptor를 구현하여 쿠키에 “LogIn”의 값이 존재한다면 true를 반환하도록 하였다. 
        
        추가로, 로그인 유지가 아니라 로그인 메서드 자체에서도 고민을 했다.
        
        클라이언트에게 입력 받은 id와 pw를 파라미터로 가져 와 db에서 비교하여 일치하는 테이블에 데이터가 있다면 로그인 처리를 하고자 했다. 이 경우 몇 가지 문제가 존재했다. **사용자의 pw를 들고 비교한다면 보안 상 문제가 발생**할 수 있다. 보안을 강화하기 위한 다양한 방법을 찾아 보았다.
        
        1. 비밀번호 해싱
            1. 비밀번호 해싱 : 사용자가 회원가입할 때 입력한 비밀번호 그대로 DB에 저장하는 것이 아니라, 해시 함수를 통해 해시된 값으로 변환하여 저장한다. 해싱된 비밀번호는 복호화가 불가능하기 때문에 보안성이 높다. 이래서 최근 비밀번호를 잊으면 이전에 설정한 비밀번호를 알려주는 것이 아니라 임시 비밀번호 발급 혹은 새로 지정할 수 있도록 하는 것 같다.
            2. 다양한 해시 알고리즘을 사용하고, 동일한 비밀번호 일지라도 비밀번호에 무작위로 ‘소금’을 추가해 해싱 해 같은 비밀번호라도 해시 값이 다르게 생성된다고 한다. 
            3. 로그인 시 해싱된 비밀번호와 비교 : 로그인 시에도 사용자가 로그인을 위해 입력한  pw를 서버에서 이전에 회원가입 때 pw를 저장하기 위해 사용했던 해시 알고리즘을 사용하여 해싱한다. 이를 DB에 저장된 해싱 pw값과 비교한다. 
        2. 로그인 흐름에서 보안 강화 방안
            1. SSL/TLS 사용 : 네트워크를 통해 비밀번호가 전송될 때 SSL/TLS 암호화로 보호하여 중간에서 데이터가 유출되는 것을 방지한다.
            2. JWT 또는 세션 토큰 : 로그인 후 인증 상태를 유지할 때 세션 대신 JWT나 세션 토큰을 사용하여 서버의 부담을 줄이고 보안을 강화한다. JWT는 필요할 때마다 재발행하여 클라이언트에게 전달되고, 이후 요청마다 인증 상태를 검증할 수 있다.
        
        이러한 다양한 방법으로 현업에선 보안을 유지한다고 한다. 그러나 이 방법을 알지 못 해서 직접 id와 pw를 문자 그대로 가져가 비교하는 방식으로 로그인을 구현했다. 
        
        발생한 또다른 문제는 db에 저장된 id/pw 값과 로그인을 위해 입력한 id/pw 값을 비교하고자 했는데 **mapper에서 parameter값으로 두 개의 값을 넘겨주기 곤란**했다. 이를 위해 mapper의 로직을 변경했다. db에 사용자가 로그인을 위해 입력한 id에 일치하는 유저가 존재한다면 해당 유저 데이터를 반환한다. 반환된 유저 데이터의 pw와 로그인을 위해 입력된 pw가 일치한다면 로그인 처리하는 것으로 변경했다. 
        
    - 대댓글을 위한 DB 설계 방식 수정
        
        이전에 리뷰의 대댓글 기능을 고민하며 DB를 설계할 때 review 테이블 내에 parent_review_id를 추가했다. 이 값이 0이라면 원댓글이고, 대댓글이라면 원 댓글의 review_id값을 갖도록 하고자 했다. default로 0을 갖도록 했고, not null 처리를 했다. 하지만 parent_review_id도 review 테이블의 review_id를 참조하는 것이기 때문에, 데이터 무결성을 위해 외래키로 설정하는 것이 좋다는 의견을 받았다. 이 과정에서 parent_review_id의 기본 값을 0으로 설정할 경우 외래키 제약 조건과 충돌될 수 있다. review_id 자체를 AUTO_INCREMENT처리하여 0이라는 값이 존재하지 않기 때문이다. 이를 해결하기 위해 간단하게 null을 허용하는 방식으로 취했다. 즉, 원댓글의 경우 parent_review_id는 0이 아닌 null값을 갖게 되고, default값으로 null을 부여했다.
